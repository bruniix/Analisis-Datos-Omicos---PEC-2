---
title: "PEC2"
author: "Bruno Bel"
date: "2025-12-14"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, warning = FALSE)
```
#Introducción

Los archivos y el código generado para realizar los análisis posteriores se encuentran en el repositorio llamado "Analisis-Datos-Omicos---PEC-2" al que se puede acceder mediante el siguiente ![enlace al repositorio.](https://github.com/bruniix/Analisis-Datos-Omicos---PEC-2).

Para dicha resolución se ha trabajado con R y utilizando RMarkdown para la escritura y ejecución.

#Obtención de los datos

En primer lugar, tal como se indica en la propuesta del ejercicio, los datos de el estudio se encuentran en la plataforma Gene Expression Omnibus mediante el identificador [GSE161731](https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE161731).

Como se describe en la plataforma, en el estudio dispusieron de 46 pacientes con COVID-19 alguno de ellos tomando varias muestras en momentos distintos llegando al número total de 77 muestras de sangre periférica.

Para la comparación transcriptómica y de la expressión génica compararon las muestras con las almacenadas de otros pacientes diagnosticados con infección respiratoria aguda debída a coronavirus estacional, al virus de la gripe, neumonía bacteriana o pacientes control.

Además los pacientes de estudio fueron divididos en grupos según la gravedad de la infección aparente debido a lo sintomas expresados y mediante tiempo en relación al desarrollo de la enfermedad.

Para empezar vamos a descargar los datos mediante el paquete GEOquery que nos permite acceder directamente a la base de datos.

```{r}
#carga de librerias y paquetes

if (!requireNamespace("BiocManager", quietly = TRUE))
    install.packages("BiocManager")

paquetes <- c("GEOquery", "SummarizedExperiment", "EnsDb.Hsapiens.v86", "GenomicFeatures", "edgeR")
for (p in paquetes) {
    if (!requireNamespace(p, quietly = TRUE))
        BiocManager::install(p)
    library(p, character.only = TRUE)
}



```
## Descarga datos GEO, preparación datos contaje y metadatos

```{r}

DATA <- getGEO("GSE161731")

DATA[[1]]

cat("Habiendo descargado los datos mediante el paquete GEOquery, obtenemos eluna lista que contiene ub objeto de tipo:",class(DATA[[1]]))


cat("\n Utilizando la funcion experimentData() visualizamos la información asociada al caso de GEO y el enlace para realizar lad escarga de los datos de expresión 'assay data'.")

experimentData(DATA[[1]])

download.file("ftp://ftp.ncbi.nlm.nih.gov/geo/series/GSE161nnn/GSE161731/suppl/GSE161731_counts.csv.gz", destfile = "GSE161731_GEO_submission_counts.txt.gz")

count_matrix <- read.csv("GSE161731_GEO_submission_counts.txt.gz", header = FALSE, row.names = 1)

colnames(count_matrix) <- count_matrix[1,]

count_matrix <- count_matrix[-1, ]

count_matrix <- as.matrix(count_matrix)

cat("\n Las dimensiones del objeto descargado que contiene los datos de expresión son:",dim(count_matrix), "Podemos hacernos una idea de la distribución de los datos viendo la expresión genica para algunas de las muestras.")

knitr::kable(count_matrix[1:10, 1:10])

metadata <- pData(DATA[[1]])

cat("\n Las dimensiones del objeto importado de la base de datos de GEO, que contiene los metadatos (información en relación a las muestras y los pacientes) son", dim(metadata), "Podemos hacernos una idea de la distribución de los datos viendo los registros para algunas muestras.")


knitr::kable(metadata[1:10, 1:10])


```

Vemos que los metadatos importados de la base de datos GEO tienen su identificador própio, lo que nos impide relacionarlos con las muestras correspondientes. Modificamos el nombre de las filas para que corresponda con los carácteres de interés de la variable "titulo".

```{r}
library(tidyverse)
rownames(metadata) <- str_sub(metadata$title, 14)
```

Para preparar el objeto SummarizedExperiment debemos en primer lugar asegurar que disponemos de información para las muestas de las cuales se ha obtenido el trasnscriptoma y la anotación genica para los genes cuantificados.

Ya hemos visto que las dimensiones eran distintas para ambos objetos, por lo que cabe suponer que hay 3 muestras de las cuales no se dispone información (ncol(count_matrix)-nrow(metadata)). 

```{r}
muestras <- intersect(rownames(metadata), colnames(count_matrix))

cat("Al haber realizado la intersección tenemos el mismo identificador, y por tanto información completa, para un total de", length(muestras)," muestras.")

count_filtrado <- count_matrix[, muestras]
metadata_filtrado <- metadata[muestras, ]


```
## Descarga datos genes y filtrado según genes en común

```{r}
#genes rowranges 

gene_ranges <- genes(EnsDb.Hsapiens.v86)

gene_ids <- rownames(count_filtrado)

gene_ids_annotation <- names(gene_ranges)

gene_comun <- intersect(gene_ids, gene_ids_annotation)

count_filtrado <- count_filtrado[gene_comun, ]
gene_ranges_final <- gene_ranges[gene_comun]

cat("Después de haber seleccionado los genes y carácteristicas comunes las dimensiones de la matriz de contajes quedan siendo: ", dim(count_filtrado))

```

## Creación obtejo SummarizedExperiment

Una vez tenemos la matriz de contajes con las observaciones correspondientes, los metadatos con el nombre de fila correcto y hemos comprobado la coincidencia y orden correcto, podemos crear el objeto SummarizedExperiment para conseguir tener todos los datos enlazados.

```{r}
se <- SummarizedExperiment(
    assays = list(counts = count_filtrado),
    colData = metadata_filtrado,
    rowRanges = gene_ranges_final
)

print(se)


```

Como se observa al mostrar el SummarizedExperiment, está formado por 57602 genes a los cuáles se dispone de registro de expressión para 194 muestras, con 67 columnas con información de los metadatos y 6 variables en relación a los genes.


# Limpieza y selección de datos

## Selección de cohorte

En primer lugar seleccionamos la variables de interés para los metadatos y cambiamos el nombre para mejor interpretación.

```{r}

str(colData(se))

col_metadata_select <- c("title", "geo_accession", "age:ch1", "batch:ch1", "cohort:ch1", "gender:ch1", "hospitalized:ch1", "race:ch1", "subject_id:ch1", "time_since_onset:ch1")

colData(se) <- colData(se)[, col_metadata_select]

cat("Columnas de metadatos seleccionadas:\n")

colnames(colData(se))[3:10] <- c("age", "batch", "cohort", "gender", "hospitalized", "race", "id", "time_since_onset")

colnames(colData(se))



```

Seleccionamos las cohortes en las que estamos interesados, cogeremos solo las muestras que corresponden clasificadas como: COVID19, Bacterial y healthy.

```{r}
library(tidyverse)

cat("Actualmente las clasificaciones para las variables de la cohorte son:", unique(colData(se)$cohort))

cohortes_seleccionadas <- c("COVID-19", "Bacterial", "healthy")

se <- se[, se$cohort %in% cohortes_seleccionadas]


table(se$cohort)


```

Vemos que del número inicial de muestras quedan 117 según las cohortes y pacientes con el estado inmunológico de interés-

## Revisión datos

A continuación antes de passar al análisis de los datos, revisamos que no hayan individuos repetidos y que las variables sean del tipo que corresponde

```{r}
cat("El número de identificadores de las muestras y de entradas coincide:", length(colnames(se)) == length(unique(colData(se)$id)) )

se <- se[, !duplicated(se$id)]

cat("Habiendo eliminado los duplicados, ahora el número total de observaciones / muestras es de:", length(colnames(se)))

colnames(se) <- se$id

```

Eliminamos espacios en blanco de la variable raza y cambiamos el tipo de variable: edad a númerica y batch, cohorte, genero y raza a factor.

```{r}
colData(se)$race <- gsub(" ", "_", colData(se)$race)

variables_categoricas <- c("batch", "cohort", "gender", "race")

colData(se)[variables_categoricas] <- lapply(colData(se)[variables_categoricas], as.factor)

se_backup <- se

```

Al transformar la variable edad a númerica aparece el aviso de que se han introducido valores NA's. Buscamos los valores únicos para observar cuales no pueden ser asociados a un número entero.

```{r}
cat("Todos los valores de la variable 'age' :", unique(se$age))

table(se$age)

cat("El valor que se introduce como NA es la edad registrada como >89, puesto que es la única observación transformamos este número a 89 entero.")

se$age <- gsub(">89", "89", se$age)

se$age <- as.numeric(se$age)

summary(se$age)

```
## Semilla aleatoria y selección de muestras.

```{r}
myseed <- sum(utf8ToInt("brunobelgomez"))
cat("La semilla generada para la selección aleatoria de los datos es:", myseed)

set.seed(myseed)
select <- sample(1:ncol(se), 75)
se <- se[, select]

cat("Posterior a la selección aleatoria la distribución de muestras queda de la siguiente manera.")
table(se$cohort)


se_backup <- se

```

# Preprocesado, selección genes y transformación

## Filtrado de genes

Antes de realizar el análisis y clasificación debemos hacer una selección de los genes a contabilizar. Genes con una muy baja expresión o sin expresión no son relevantes para realizar la comparación entre grupos de distinta cohorte. 

```{r}
library(edgeR)

```

